mod* Content{
[cont]

op _=_ : cont cont -> Bool {comm}

var C1  : cont

eq (C1 = C1) = true .

}

mod* Permission{ --sssss
pr(Content)
[action < perm ]

ops play display print export execute : -> action
op _=_ : action action -> Bool {comm }

op <_,_> : action cont -> perm 

vars A1 A2 : action

eq (A1 = A1) = true .

}

mod* Request{
pr(Permission + Content)
[req]

op _,_ : cont action -> req
op null : -> req

op _=_ : req req -> Bool {comm} 

op belong1?(_,_) : req  perm -> Bool

vars C1 C2 : cont
vars A1 A2 : action
var R : req 

ceq belong1?((C1,A1),< A2 , C2 >) = true if (C1 = C2) and (A1 = A2) .

eq (R = R) = true .

}


mod! Colors{
[color]
ops black white : -> color
op _=_ : color color -> Bool {comm}

eq (black = black ) = true .
eq (white = white) = true .
eq (black = white) = false .
}


mod! Label{
[type1 , type2 ,type3 < label]

op _=_ : label label -> Bool {comm}
op _=_ : type1 type1 -> Bool {comm}
op _=_ : type2 type2 -> Bool {comm}
op _=_ : type3 type3 -> Bool {comm}

ops simple complex  : -> type1
ops count datetime true : -> type2
ops once many : -> type3

op _ & _ & _ : type1 type2 type3 -> label

op type1?_ : label -> type1
op type2?_ : label -> type2
op type3?_ : label -> type3

var t1 : type1
var t2 : type2
var t3 : type3 


eq type1?(t1 &  t2 & t3) = t1 .
eq type2?(t1 & t2 &  t3) = t2 .
eq type3?(t1 & t2 &  t3) = t3 .

eq (t1 = t1 ) = true .
eq (t2 = t2 ) = true .
eq (t3 = t3 ) = true .
}


-- Module that defines the parametrized datatype of a SET
mod* SET(X :: TRIV){
pr(NAT)
-- Sorts
[Elt < Set]
-- Constructors
op empty : -> Set
op _,_   : Set Set -> Set {comm}
-- Operators ï¿½
op _/in_ : Elt Set -> Bool
op _=_   : Set Set -> Bool {comm}
op #_    : Set     -> Nat
-- axioms (equations)
var S : Set .
var e : Elt .
var e' : Elt .

eq (e , empty) = e .
eq (e,e) = e .
ceq (e , S) = S if (e /in S) .
eq (S = S ) = true .
ceq (e /in e') = true if (e = e') .
ceq (e /in e' , S) = true if (e = e') or (e /in S) .
eq # e = 1 .
eq # (e , S) = #(S) + 1 .
}


-- Module that specifies a constraint in OMA REL 
mod! Constraint {
pr(NAT)
[cons]
ops trueCons  interval datetime : -> cons
op count[_] : Nat -> cons
op timedcount[_] : Nat  -> cons

op _>_ : cons cons -> Bool

var n : Nat

eq (trueCons > trueCons) = false .
eq (trueCons > count[n] ) = true .
eq (trueCons > timedcount[n] ) = true .
eq (trueCons > interval) = true .
eq (trueCons > datetime) = true .

eq (datetime > trueCons) = false .
eq (datetime > count[n] ) = true .
eq (datetime > timedcount[n] ) = true .
eq (datetime > interval) = true .
eq (datetime > datetime) = false .

eq (interval > trueCons) = false .
eq (interval > count[n] ) = true .
eq (interval > timedcount[n] ) = true .
eq (interval > interval) = false .
eq (datetime > datetime) = false .


eq (timedcount[n] > trueCons) = false .
eq (timedcount[n] > count[n] ) = true .
eq (timedcount[n] > timedcount[n] ) = false .
eq (timedcount[n] > interval) = false .
eq (timedcount[n] > datetime) = false .


eq (count[n] > trueCons) = false .
eq (count[n] > count[n] ) = false .
eq (count[n] > timedcount[n] ) = false .
eq (count[n] > interval) = false .
eq (count[n] > datetime) = false .
}


-- Module that specifies the set of constraints in OMA
mod! ConstraintSet{

pr(SET(Constraint {sort Elt -> cons})
*{sort Set -> consSet, op empty -> emptcons})
-- operator cons0? takes as input a constraint set and returns the best constraint based
-- on the OMA ordering on constraints
op cons0? : consSet -> cons
op _=_ : consSet consSet -> Bool

var C1 : cons
var CS : consSet

ceq cons0?(C1 , CS) = C1 if (C1 > cons0?(CS)) .
eq cons0?(C1) = C1 .
eq (C1 = C1) = true .

}




-- Module that specifies the set of permission in OMA
mod! PermissionSET{

pr(SET(Permission {sort Elt -> perm})
*{sort Set -> permSet, op empty -> emptperm})
pr(Request)

op belong2?(_,_) : req permSet -> Bool
op _=_ : permSet permSet -> Bool {comm}

var C1 : cont
var A1 : action
var P1 : perm
var PS : permSet

ceq belong2?((C1,A1) , (P1 , PS) ) = true if ( belong1?((C1,A1),P1)) or (belong2?((C1,A1) , PS)) .
eq (PS = PS) = true .
}


-- Specifies a Constraint Permission 
mod! ConstraintPermission{
pr(PermissionSET + ConstraintSet + Label )
pr(Request)

[cPerm]

op _=_ : cPerm cPerm -> Bool {comm}
op null : -> cPerm
op _about_ : consSet permSet -> cPerm
op labelCP?_ : cPerm -> label

op cons1? : req cPerm -> cons

op belong3?(_,_) : req cPerm -> Bool

-- operator conPerm1? checks if a the set of constraints for a permission set holds

op conPerm1?      : cPerm -> Bool 


var R : req 
vars C C' : consSet
vars P P' : permSet

ceq belong3?(R,C about P) = true if belong2?(R,P)  .
eq cons1?(R , (C about P)) = cons0?(C) .


ceq (( C about P)  = ( C' about P')) = true  if (C = C') and (P = P') .


}


-- Specifies a set of Constraint Permissions
mod! SetofCP{
pr(SET(ConstraintPermission { sort Elt -> cPerm})
*{sort Set -> setofCP, op empty -> emptySetofCP}
)

-- operator conPerm2? checks if for all permission sets their constraints holds
-- ------------------------------
op conPerm2? : setofCP -> Bool .

op find1 : req setofCP -> cPerm
op belong4? : req setofCP -> Bool
op cons2? : req setofCP -> cons

var R : req
var CPS : setofCP
var CP : cPerm

ceq find1(R , (CP , CPS)) = CP if (belong3?(R , CP)).
ceq find1(R , (CP , CPS)) = find1(R , CPS) if not(belong3?(R,CP)) .
ceq find1(R, CP) = null if not (belong3?(R,CP)) .

ceq belong4?(R, (CP, CPS)) = true if ( (belong3?(R, CP)) or (belong4?(R, CPS)) ) .
eq belong4?(R, CP) = belong3?(R, CP) .

eq cons2?(R , CPS) = cons1?(R , find1(R , CPS)) .


eq conPerm2?(emptySetofCP) = true .
eq conPerm2?( CP , CPS) = ( conPerm1?(CP) and conPerm2?(CPS)) .

}


mod! Sublicense{
pr(ConstraintPermission + SetofCP )

[subLic]
op nill : -> subLic
op _about_ : consSet setofCP -> subLic

op subCons1? : subLic -> Bool
op subCons?  : req subLic -> Bool

op label?_ : subLic -> label
op find2 : req subLic -> cPerm
op belong5? : req subLic -> Bool
op cons3? : req subLic -> cons

var R : req
var CPS : setofCP
var C : consSet

eq find2(R , C about CPS) = find1(R, CPS) . 

eq belong5?(R , C about CPS) = belong4?(R, CPS) .

ceq cons3?(R , C about CPS) = cons0?(C) if ( cons0?(C) > cons2?(R ,CPS)) .
ceq cons3?(R , C about CPS) = cons2?(R , CPS) if (cons2?(R , CPS) > cons0?(C)) .

ceq subCons?(R , C about CPS) = true if ( subCons1?(C about CPS) 
    	       	   	      	     and (conPerm2?( find1(R , CPS)))) .

}


mod! License{
pr(SET(Sublicense { sort Elt -> subLic})
*{sort Set -> lic, op empty -> emptyLic}
)

-- operator find3 takes as input a user request and a  license and returns
-- the constraint permission set the request belongs too
-- we assume that in a single licenses theres is only one CPerm that refers to 
-- that request for simplicity without hurting generality 

-- find4 works simirally only returns the sublicese that the right belongs to not the CPerm


-- operator belong6? takes as input a request and a license and returns true or false
-- depending on whether the request belongs to the license or not.

op find4 : req lic -> subLic
op find3 : req lic -> cPerm
op belong6? : req lic -> Bool

op cons4?  : req lic -> cons


var R : req
var L : lic
var subL : subLic


ceq find3(R , (subL , L)) = find2(R , subL) if not( find2(R , subL) = null ) .
ceq find3(R , (subL , L)) = find3(R , L)   if  ( find2(R , subL) = null ) .
eq find3(R , subL) = find2(R , subL) .



ceq find4(R , (subL , L)) = subL if belong5?(R , subL) .
ceq find4(R , (subL , L)) =  find4(R ,  L) if not  belong5?(R , subL) . 
ceq find4(R , subL ) = subL if  belong5?(R , subL) .
ceq find4(R , subL ) = nill if not  belong5?(R , subL) .


eq belong6?(R , (subL , L)) = (belong5?(R , subL) or belong6?(R , L)) .
eq belong6?(R , subL) = belong5?(R ,subL) . 

eq cons4?(R , L) = cons3?(R , find4(R , L)) .

}


mod! LicSet{
pr(SET(License { sort Elt -> lic})
*{sort Set -> licSet, op empty -> emptyLicSet}
)

-- operator bestLic takes as input a set of licenses and a request and returns the best
-- constraint that refers to the request based on the OMA ordering

op bestLic : req licSet -> cons

var L  : lic
var LS : licSet
var R  : req

eq bestLic(R , L) = cons4?(R , L) .
ceq bestLic( R , (L, LS)) = cons4?(R , L) if (cons4?(R , L) > bestLic(R ,LS)) .
ceq bestLic( R , (L, LS)) = bestLic(R , LS) if ( bestLic(R ,LS) > cons4?(R ,L)) .
}


